第 十 章        群体数据的组织


10-1 简单说明插入排序的算法思想。


解： 
插入排序的基本思想是：每一步将一个待排序元素按其关键字值的大小插入到已排序序列的适当位置上，直到待排序元素插入完为止。


10-2 初始化整型数组data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20}，调用教材中的直接插入排序函数模板进行排序，对此函数模板稍做修改，加入输出语句，在每插入一个待排序元素后显示整个数组，观察排序过程中数据的变化，加深对插入排序算法的理解。


解： 
#include <iostream.h> 

template <class T>
void InsertionSort(T A[], int n)
{
int i, j;
T temp;

// 将下标为1～n-1的元素逐个插入到已排序序列中适当的位置
for (i = 1; i < n; i++) 
{
//从A[i-1]开始向A[0]方向扫描各元素,寻找适当位置插入A[i]
j = i;
temp = A[i];
while (j > 0 && temp < A[j-1]) 
{ //逐个比较，直到temp>=A[j-1]时，j便是应插入的位置。
//若达到j==0，则0是应插入的位置。
A[j] = A[j-1];
//将元素逐个后移，以便找到插入位置时可立即插入。
j--;
}
// 插入位置已找到，立即插入。
A[j] = temp;

//输出数据
for(int k=0;k<n;k++)
cout << A[k] << " ";
cout << endl;
//结束输出 
}
}

void main()
{
int i;

int data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20};
cout << "排序前的数据：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
cout << "开始排序..." << endl;
InsertionSort(data1, 20);
cout << "排序后的数据：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
}
程序运行输出：
排序前的数据：
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
开始排序...
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 2 3 5 7 9 11 13 15 17 19 4 6 8 10 12 14 16 18 20 
1 2 3 4 5 7 9 11 13 15 17 19 6 8 10 12 14 16 18 20 
1 2 3 4 5 6 7 9 11 13 15 17 19 8 10 12 14 16 18 20 
1 2 3 4 5 6 7 8 9 11 13 15 17 19 10 12 14 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 13 15 17 19 12 14 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 15 17 19 14 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 17 19 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 19 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
排序后的数据：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 

 

10-3 简单说明选择排序的算法思想。


解： 
选择类排序的基本思想是：每次从待排序序列中选择一个关键字最小的元素，（当需要按关键字升序排列时），顺序排在已排序序列的最后，直至全部排完。


10-4 初始化整型数组data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20}，调用教材中的直接选择排序函数模板进行排序，对此函数模板稍做修改，加入输出语句，每对一个待排序元素排序后显示整个数组，观察排序过程中数据的变化，加深对直接选择排序算法的理解。


解： 
#include <iostream.h>

// 辅助函数：交换x和y的值
template <class T>
void Swap (T &x, T &y)
{
T temp;

temp = x;
x = y;
y = temp;
}

// 用选择法对数组A的n个元素进行排序
template <class T>
void SelectionSort(T A[], int n)
{
int smallIndex; //每以趟中选出的最小元素之下标
int i, j;

// sort A[0]..A[n-2], and A[n-1] is in place
for (i = 0; i < n-1; i++) 
{
smallIndex = i; //最小元素之下标初值设为i
// 在元素A[i+1]..A[n-1]中逐个比较显出最小值
for (j = i+1; j < n; j++) 
// smallIndex始终记录当前找到的最小值的下标
if (A[j] < A[smallIndex])
smallIndex = j;
// 将这一趟找到的最小元素与A[i]交换
Swap(A[i], A[smallIndex]);
//输出数据
for(int k=0;k<n;k++)
cout << A[k] << " ";
cout << endl;
//结束输出 

}
}

void main()
{
int i;

int data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20};
cout << "排序前的数据：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
cout << "开始排序..." << endl;
SelectionSort(data1, 20);
cout << "排序后的数据：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
}
程序运行输出：
排序前的数据：
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
1 2 5 7 9 11 13 15 17 19 3 4 6 8 10 12 14 16 18 20 
1 2 3 7 9 11 13 15 17 19 5 4 6 8 10 12 14 16 18 20 
1 2 3 4 9 11 13 15 17 19 5 7 6 8 10 12 14 16 18 20 
1 2 3 4 5 11 13 15 17 19 9 7 6 8 10 12 14 16 18 20 
1 2 3 4 5 6 13 15 17 19 9 7 11 8 10 12 14 16 18 20 
1 2 3 4 5 6 7 15 17 19 9 13 11 8 10 12 14 16 18 20 
1 2 3 4 5 6 7 8 17 19 9 13 11 15 10 12 14 16 18 20 
1 2 3 4 5 6 7 8 9 19 17 13 11 15 10 12 14 16 18 20 
1 2 3 4 5 6 7 8 9 10 17 13 11 15 19 12 14 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 13 17 15 19 12 14 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 17 15 19 13 14 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 15 19 17 14 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 19 17 15 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 17 19 16 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 19 17 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 19 18 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
排序后的数据：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 

 

10-5 简单说明交换排序的算法思想。


解： 
交换排序的基本思想是：两两比较待排序序列中的元素，并交换不满足顺序要求的各对元素，直到全部满足顺序要求为止。


10-6 初始化整型数组data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20}，调用教材中的起泡排序函数模板进行排序，对此函数模板稍做修改，加入输出语句，每完成一趟起泡排序后显示整个数组，观察排序过程中数据的变化，加深对起泡排序算法的理解。


解： 
#include <iostream.h>

// 辅助函数：交换x和y的值
template <class T>
void Swap (T &x, T &y)
{
T temp;

temp = x;
x = y;
y = temp;
}

// 用起泡法对数组A的n个元素进行排序
template <class T>
void BubbleSort(T A[], int n)
{
int i,j; 
int lastExchangeIndex; 
//用于记录每趟被交换的最后一对元素中较小的下标
i = n-1; // i是下一趟需参与排序交换的元素之最大下标

while (i > 0)
//持续排序过程，直到最后一趟排序没有交换发生，或已达n-1趟
{
lastExchangeIndex = 0; 
//每一趟开始时，设置交换标志为0（未交换）
for (j = 0; j < i; j++) //每一趟对元素A[0]..A[i]进行比较和交换
if (A[j+1] < A[j]) //如果元素A[j+1] < A[j]，交换之
{ 
Swap(A[j],A[j+1]);
lastExchangeIndex = j; 
//记录被交换的一对元素中较小的下标
}

// 将i设置为本趟被交换的最后一对元素中较小的下标
i = lastExchangeIndex;
//输出数据
for(int k=0;k<n;k++)
cout << A[k] << " ";
cout << endl;
//结束输出 

}
}

void main()
{
int i;

int data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20};
cout << "排序前的数据：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
cout << "开始排序..." << endl;
BubbleSort(data1, 20);
cout << "排序后的数据：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
}

程序运行输出：
排序前的数据：
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
开始排序...
1 3 5 7 9 11 13 15 17 2 4 6 8 10 12 14 16 18 19 20 
1 3 5 7 9 11 13 15 2 4 6 8 10 12 14 16 17 18 19 20 
1 3 5 7 9 11 13 2 4 6 8 10 12 14 15 16 17 18 19 20 
1 3 5 7 9 11 2 4 6 8 10 12 13 14 15 16 17 18 19 20 
1 3 5 7 9 2 4 6 8 10 11 12 13 14 15 16 17 18 19 20 
1 3 5 7 2 4 6 8 9 10 11 12 13 14 15 16 17 18 19 20 
1 3 5 2 4 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
1 3 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
排序后的数据：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 


10-7 教材中的排序算法都是升序排序，稍做修改后即可完成降序排序，以起泡排序法为例，完成降序的起泡排序函数模板，初始化整型数组data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20}，调用降序起泡排序函数模板进行排序，加入输出语句，每完成一趟起泡排序后显示整个数组，观察排序过程中数据的变化。


解： 
#include <iostream.h>

// 辅助函数：交换x和y的值
template <class T>
void Swap (T &x, T &y)
{
T temp;

temp = x;
x = y;
y = temp;
}

// 用起泡法对数组A的n个元素进行排序
template <class T>
void BubbleSort(T A[], int n)
{
int i,j; 
int lastExchangeIndex; 
//用于记录每趟被交换的最后一对元素中较小的下标
i = n-1; // i是下一趟需参与排序交换的元素之最大下标

while (i > 0) 
//持续排序过程，直到最后一趟排序没有交换发生，或已达n-1趟
{
lastExchangeIndex = 0; 
//每一趟开始时，设置交换标志为0（未交换）
for (j = 0; j < i; j++) //每一趟对元素A[0]..A[i]进行比较和交换
if (A[j+1] > A[j]) //如果元素A[j+1] < A[j]，交换之
{ 
Swap(A[j],A[j+1]);
lastExchangeIndex = j; 
//记录被交换的一对元素中较小的下标
}

// 将i设置为本趟被交换的最后一对元素中较小的下标
i = lastExchangeIndex;
//输出数据
for(int k=0;k<n;k++)
cout << A[k] << " ";
cout << endl;
//结束输出 

}
}

void main()
{
int i;

int data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20};
cout << "排序前的数据：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
cout << "开始排序..." << endl;
BubbleSort(data1, 20);
cout << "排序后的数据：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
}
程序运行输出：
排序前的数据：
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
开始排序...
3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 1 
5 7 9 11 13 15 17 19 3 4 6 8 10 12 14 16 18 20 2 1 
7 9 11 13 15 17 19 5 4 6 8 10 12 14 16 18 20 3 2 1 
9 11 13 15 17 19 7 5 6 8 10 12 14 16 18 20 4 3 2 1 
11 13 15 17 19 9 7 6 8 10 12 14 16 18 20 5 4 3 2 1 
13 15 17 19 11 9 7 8 10 12 14 16 18 20 6 5 4 3 2 1 
15 17 19 13 11 9 8 10 12 14 16 18 20 7 6 5 4 3 2 1 
17 19 15 13 11 9 10 12 14 16 18 20 8 7 6 5 4 3 2 1 
19 17 15 13 11 10 12 14 16 18 20 9 8 7 6 5 4 3 2 1 
19 17 15 13 11 12 14 16 18 20 10 9 8 7 6 5 4 3 2 1 
19 17 15 13 12 14 16 18 20 11 10 9 8 7 6 5 4 3 2 1 
19 17 15 13 14 16 18 20 12 11 10 9 8 7 6 5 4 3 2 1 
19 17 15 14 16 18 20 13 12 11 10 9 8 7 6 5 4 3 2 1 
19 17 15 16 18 20 14 13 12 11 10 9 8 7 6 5 4 3 2 1 
19 17 16 18 20 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 
19 17 18 20 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 
19 18 20 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 
19 20 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 
20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 
排序后的数据：
20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 

 

10-8 简单说明顺序查找的算法思想。


解： 
顺序查找是一种最简单、最基本的查找方法。
其基本思想是：从数组的首元素开始，逐个元素与待查找的关键字进行比较，直到找到相等的。若整个数组中没有与待查找关键字相等的元素，就是查找不成功。


10-9 初始化整型数组data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20}，提示用户输入一个数字，调用教材中的顺序查找函数模板找出它的位置。


解： 
#include <iostream.h>

template <class T>
int SeqSearch(T list[], int n, T key)
{
for(int i=0;i < n;i++)
if (list[i] == key)
return i; 
return -1; 
}

void main()
{
int i, n;

int data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20};
cout << "输入想查找的数字(1~20)：";
cin >> n;
cout << "数据为：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
i = SeqSearch ( data1 , 20 , n );
if (i<0)
cout << "没有找到数字" << n << endl;
else
cout << n << "是第" << i+1 << "个数字" << endl;
}

程序运行输出：
输入想查找的数字(1~20)：6
数据为：
1 3 5 7 9 11 13 15 17 19 2 4 6 8 10 12 14 16 18 20 
6是第13个数字

 

10-10 简单说明折半查找的算法思想。


解： 
如果是在一个元素排列有序的数组中进行查找，可以采用折半查找方法。
折半查找方法的基本思想是：对于已按关键字排序的序列，经过一次比较，可将序列分割成两部分，然后只在有可能包含待查元素的一部分中继续查找，并根据试探结果继续分割，逐步缩小查找范围，直至找到或找不到为止。


10-11 初始化整型数组data1[]={1,3,5,7,9,11,13,15,17,19,2,4,6,8,10,12,14,16,18,20}，提示用户输入一个数字，调用教材中的折半查找函数模板找出它的位置。


解： 
#include <iostream.h>

// 用折半查找方法，在元素呈升序排列的数组list中查找值为key的元素
template <class T>
int BinSearch(T list[], int n, T key)
{
int mid, low, high;
T midvalue;
low=0;
high=n-1;
while (low <= high) // low <= high表示整个数组尚未查找完
{
mid = (low+high)/2; // 求中间元素的下标
midvalue = list[mid]; // 取出中间元素的值
if (key == midvalue) 
return mid; // 若找到,返回下标
else if (key < midvalue)
high = mid-1; 
// 若key < midvalue将查找范围缩小到数组的前一半
else
low = mid+1; // 否则将查找范围缩小到数组的后一半
}
return -1; // 没有找到返回-1
}

void main()
{
int i, n;

int data1[]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};
cout << "输入想查找的数字(1~20)：";
cin >> n;
cout << "数据为：" << endl;
for(i=0;i<20;i++)
cout << data1[i] << " ";
cout << endl;
i = BinSearch ( data1 , 20 , n );
if (i<0)
cout << "没有找到数字" << n << endl;
else
cout << n << "是第" << i+1 << "个数字" << endl;

}

程序运行输出：
输入想查找的数字(1~20)：9
数据为：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
9是第9个数字

 
